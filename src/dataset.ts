//import { utils } from './utils';
import { InstanceFactory } from './component';
import { IRecord, IField, IDataSource, RecordState, DataEventType, RecordSetSource } from './data';
import { application } from './application';
import { IService, IResponse } from './service';
import { utils } from './utils';

// Interfaces

/** Enumerates types of events generated by data set */
export enum DataSetEventType { Refreshed, Updated };

/** Record state for cached updates */
export enum RecordUpdateType { Deleted = 1, Modified = 2, Inserted = 3 };

/** Event type that raised when something changes in the data set */
export interface IOnDataSetChangeEvent {
    (eventType: DataSetEventType, data?: any): void;
}

/** Describes a datasource link */
export interface IDataSetLink {
    onChange(eventType: DataSetEventType, data: any): void;
}

/** Describes an object that maintains data source links */
export interface IDataSet {
    addLink(link: IDataSetLink): void;
    removeLink(link: IDataSetLink): void;
    notifyLinks(eventType: DataSetEventType, data?: any): void;
}

/** Describes an object containing data table */
export interface IDataTable extends IDataSet {
    tableName: string;
    fields: IField[];
    records: IRecord[];
    createRecord(): IRecord;
    //internalRead(obj: any): void;
    fill(): Promise<any>;
    applyUpdates(): Promise<any>;
}

/** Describes an object containing several data tables */
export interface IDataTableSet {
    tables: IDataTable[];
    adapter: IDataTableSetAdapter;
    fill(): Promise<any>;
    update(): Promise<any>;
}

/** Describes an object for remote data manipulation */
export interface IDataAdapter {
    execute(command: string, params: any): Promise<any>;
}

/** Describes an object for table remote data manipulation */
export interface IDataTableAdapter extends IDataAdapter {
    fill(dataTable: IDataTable): Promise<any>;
    update(dataTable: IDataTable): Promise<any>;
}

/** Describes an object document remote data manipulation */
export interface IDataTableSetAdapter extends IDataAdapter {
    fill(dataSet: IDataTableSet): Promise<any>;
    update(dataSet: IDataTableSet): Promise<any>;
}


// Implementation

/** Object contaning its metainfo */
export class Record implements IRecord {
    /** Fields information */
    public static metaInfo = {
        /* implement in descendats, e:g:
            name: {
                dataType: 'string',
                dataSize: 20,
                required: false
            }
        */
    };
}

/** Record link used in cached updates */
class RecordUpdate {
    constructor(public record: IRecord, public updateType?: RecordUpdateType) {
    }
}

/** Used for cached updates */
class RecordsUpdates {
    protected _updates: RecordUpdate[] = [];
    public get updates(): RecordUpdate[] {
        return this._updates;
    }

    public clear() {
        this._updates = [];
    }

    public addUpdate(rec: IRecord, updateType: RecordUpdateType): RecordUpdate {
        let idx = this.getUpdateIndex(rec);
        if (idx === undefined)
            idx = this._updates.push(new RecordUpdate(rec)) - 1;
        let update = this.updates[idx];

        // inserted and then deleted records just removing from updates
        if (updateType == RecordUpdateType.Deleted && (update.updateType !== undefined && update.updateType == RecordUpdateType.Inserted)) {
            this.updates.splice(idx);
            return;
        }

        // updates other than Modified have higher priority
        if (!update.updateType || (update.updateType && update.updateType == RecordUpdateType.Modified))
            update.updateType = updateType;

        return update;
    }

    protected getUpdateIndex(rec: IRecord): number {
        for (let i = 0; i < this.updates.length; i++)
            if (this.updates[i].record = rec)
                return i;
    }
}

/**
 * Used for maintain DataSources inside DataSet 
 */
export class DataSetLink<T extends IDataSet> implements IDataSetLink {
    public onChangeEvent: IOnDataSetChangeEvent;
    protected _dataSet: T;

    constructor(onChangeEvent: IOnDataSetChangeEvent) {
        this.onChangeEvent = onChangeEvent;
    }

    public get dataSet(): T { return this._dataSet; }
    public set dataSet(value: T) { this.setDataSet(value); }

    public onChange(eventType: DataSetEventType, data?: any): void {
        if (this.onChangeEvent)
            this.onChangeEvent(eventType, data);
    }

    protected setDataSet(value: T) {
        if (this._dataSet != value) {
            if (this._dataSet)
                this._dataSet.removeLink(this);
            this._dataSet = value;
            if (this._dataSet)
                this._dataSet.addLink(this);
            this.onChange(DataSetEventType.Refreshed);
        }
    }
}

/** 
 * DataSet containing one table
 **/
export class DataTable<R extends Record> implements IDataTable {
    /** Table name, used in default DataAdapter */
    public tableName: string;
    /** Fields returned by service */
    public fields: IField[] = [];
    /** Records returned by service */
    public records: R[] = [];
    /** Remote data manipulation adapter */
    public adapter: IDataTableAdapter;
    /** Records constructor */
    public recordFactory: InstanceFactory<R>;

    /** Modified records */
    protected recordsUpdates = new RecordsUpdates();

    /** Links to maintained DataSources */
    protected links: IDataSetLink[] = [];

    constructor(recordFactory?: { new (): R }, owner?: DataTableSet, tableName?: string, adapter?: IDataTableAdapter) {
        this.recordFactory = recordFactory;
        this.tableName = tableName;
        if (owner)
            owner.tables.push(this);
        this.adapter = adapter;
        if (!this.adapter)
            this.adapter = new DataTableAdapter(tableName);
    }

    public add(record?: R): R {
        if (!record)
            record = this.createRecord();
        this.recordsUpdates.addUpdate(record, RecordUpdateType.Inserted);
        this.records.push(record);
        this.notifyLinks(DataSetEventType.Refreshed);
        return record;
    }

    public delete(index: number) {
        let rec = this.records[index];
        this.recordsUpdates.addUpdate(rec, RecordUpdateType.Deleted);
        this.records.splice(index);
        this.notifyLinks(DataSetEventType.Refreshed);
    }

    public update(record: R) {
        this.recordsUpdates.addUpdate(record, RecordUpdateType.Modified);
        this.notifyLinks(DataSetEventType.Refreshed);
    }

    public getMetaInfo(): any {
        if ((<any>this.recordFactory).metaInfo && !utils.isEmptyObject((<any>this.recordFactory).metaInfo))
            return (<any>this.recordFactory).metaInfo;
        else
            return this.fields;
    }

    // IDataTable implementation

    public addLink(link: IDataSetLink): void {
        this.links.push(link);
    }

    public removeLink(link: IDataSetLink): void {
        let num = this.links.indexOf(link);
        if (num >= 0)
            this.links.splice(num);
    }

    public notifyLinks(eventType: DataSetEventType, data?: any): void {
        for (let i = 0; i < this.links.length; i++) {
            this.links[i].onChange(eventType, data);
        }
    }

    public createRecord(): R {
        let newRec;
        if (this.recordFactory)
            newRec = new this.recordFactory();
        else
            newRec = new Record();
        newRec.table = this;
        return newRec;
    }

    public fill(): Promise<R[]> {
        return this.adapter.fill(this).then((records: IRecord[]) => {
            this.records = [];
            this.fields = [];
            this.recordsUpdates.clear();
            if (Array.isArray(records) && records.length > 0) {
                this.fields = RecordSetSource.getObjectFields(records[0]);
                // Records instancing
                let rec: R;
                for (let i = 0; i < records.length; i++) {
                    rec = this.createRecord();
                    for (let field in records[i]) {
                        if (records[i].hasOwnProperty(field) /*&& rec.hasOwnProperty(field)*/)
                            rec[field] = records[i][field];
                    }
                    this.records.push(rec);
                }
            }
            this.notifyLinks(DataSetEventType.Refreshed);
            return records;
        });
    }

    public applyUpdates(): Promise<any> {
        return this.adapter.update(this);
    }
}

/** DataSet containing several tables */
export class DataTableSet implements IDataTableSet {
    public tables: IDataTable[];
    public adapter: IDataTableSetAdapter;

    public fill(): Promise<any> {
        return this.adapter.fill(this);
    }

    public update(): Promise<any> {
        return this.adapter.update(this);
    }
}

/** DataSource containing one table */
export class TableDataSource<R extends Record> extends RecordSetSource {
    protected _data: DataSetLink<DataTable<R>>;

    constructor(dataTable?: DataTable<R>) {
        super();
        this._data = new DataSetLink<DataTable<R>>((eventType: DataSetEventType, data: any) => {
            if (eventType == DataSetEventType.Refreshed) {
                this.records = this.dataTable.records;
                if (!this._state)
                    this.setState(RecordState.Browse);
            }
            this.notifyLinks(DataEventType.Refreshed);
        });
        this._data.dataSet = dataTable;
    }

    public get dataTable(): DataTable<R> {
        return this._data.dataSet;
    }
    public set dataTable(dataTable: DataTable<R>) {
        if (this._data.dataSet != dataTable) {
            if (this._data.dataSet)
                this._data.dataSet.removeLink(this._data);
            dataTable.addLink(this._data);
        }
    }

    public post() {
        super.post();
        if (this._state && this._state != RecordState.Browse) {
            this.dataTable.update(<R>this.current);
            super.post();
        }
    }

    public delete(): void {
        this.checkCurrent();
        let index = this._curIndex;
        this.dataTable.delete(this._curIndex);
        if (index >= this._records.length)
            this.currentIndex = this._records.length - 1;
        else
            this.currentIndex = index;
        this.notifyLinks(DataEventType.CursorMoved);
    }

    public insert(): void {
        this.checkList();
        this.doAutoPost();
        this.dataTable.add();
        this.setState(RecordState.Insert);

        this._curIndex = this._records.length - 1;
        this._oldValue = {};
        this.notifyLinks(DataEventType.CursorMoved);
    }
}

/** Perfoms remote data manipulations */
export class DataTableAdapter implements IDataTableAdapter {
    public adapter: string;
    public service: IService;

    constructor(adapter: string) {
        this.adapter = adapter;
    }

    public execute(command: string, params?: any): Promise<any> {
        return this.getService().execute(this.adapter, command, params).then((response: IResponse) => {
            return response.data;
        });
    }

    public fill(dataTable: IDataTable): Promise<any> {
        return this.execute('fill').then((data) => {
            dataTable.records = data.records;
            return dataTable.records;
        });
    }

    public update(dataTable: IDataTable): Promise<any> {
        return this.execute('update').then((data) => {
            dataTable.records = data.records;
            return dataTable.records;
        });
    }

    protected getService(): IService {
        return this.service || application.service;
    }

}


// example code 

/*

class Customer extends Record {
    name: string;
    phone: string;
    static metaInfo =
    {
        name: {
            dataType: 'string',
            dataSize: 20,
            required: false
        }
    }
}

class Order extends Record {
}

class OrderDataSet extends DataSet {
    order = new DataTable(Order, this, 'order');
    customer = new DataTable(Customer, this, 'customer');
}

let order = new OrderDataSet();
order.customer.edit();
order.customer.name = 'Smith';
order.customer.post();
order.update();

let customerTable = new DataTable(Customer);

*/

/*
export class TableDataSet {
    public adapter: string;
    public service: IService;
    public records: IRecord[];

    constructor(adapter?: string) {
        this.adapter = adapter;
    }

    public fill(): Promise<IRecord[]> {
        return this.getService().execute(this.adapter, 'select').then((response: IResponse) => {
            this.records = response.data.records;
            return this.records;
        });
    }

    public updateRecord(index: number): Promise<void> {
        return this.getService().execute(this.adapter, 'update', this.records[index]);
    }

    public insertRecord(index: number): Promise<string> {
        return this.getService().execute(this.adapter, 'insert', this.records[index]).then((response: IResponse) => {
            let keyField = Object.keys(response.data)[0];
            this.records[index][keyField] = response.data[keyField];
            return this.records[index][keyField];
        });
    }

    public deleteRecord(index: number): Promise<void> {
        return this.getService().execute(this.adapter, 'delete', this.records[index]);
    }

    protected getService(): IService {
        return this.service || application.service;
    }
}

export class TableDataSource extends RecordSetSource {
    public dataSet: TableDataSet;

    constructor(dataSet?: TableDataSet) {
        super();
        this.dataSet = dataSet;
    }

    public fill(): Promise<IRecord[]> {
        return this.dataSet.fill().then((records: IRecord[]) => {
            this.records = records;
            this.notifyLinks(EventType.Refreshed);
            this.setState(RecordState.Browse);
            return records;
        });
    }

    public post(): Promise<void> {
        if (this._state == RecordState.Insert)
            return this.dataSet.insertRecord(this._curIndex, ).then(() => {
                super.post();
            });
        else
            return this.dataSet.updateRecord(this._curIndex, ).then(() => {
                super.post();
            });
    }

    public delete(): Promise<void> {
        if (this._state == RecordState.Insert)
            super.delete();
        else
            return this.dataSet.deleteRecord(this._curIndex).then(() => {
                super.delete();
            });
    }


}
*/

