//import { utils } from './utils';
import { InstanceFactory } from './component';
import { IRecord, RecordSetSource, RecordState, DataEventType, IDataSource, IField } from './data';
import { application } from './application';
import { IService, IResponse } from './service';

/**
 * Enumerates types of events generated by data set
 */
export enum DataSetEventType { Refreshed, Updated };

/**
 * Event type that raised when something changes in the data set
 */
export interface IOnDataSetChangeEvent {
    (eventType: DataSetEventType, data?: any): void;
}

/**
 * Describes a datasource link
 */
export interface IDataSetLink {
    onChange(eventType: DataSetEventType, data: any): void;
}

/**
 * Describes an object that maintains data source links 
 */
export interface IDataSet {
    addLink(link: IDataSetLink): void;
    removeLink(link: IDataSetLink): void;
    notifyLinks(eventType: DataSetEventType, data?: any): void;
}

/**
 * Describes an object containing data table
 */
export interface IDataTable extends IDataSet {
    tableName: string;
    fields: IField[];
    records: IRecord[];
    createRecord(): IRecord;
    //internalRead(obj: any): void;
    fill(): Promise<any>;
    update(): Promise<any>;
}

export interface IDataTableSet {
    tables: IDataTable[];
    adapter: IDataTableSetAdapter;
    fill(): Promise<any>;
    update(): Promise<any>;
}

export interface IDataAdapter {
    execute(command: string, params: any): Promise<any>;
}

export interface IDataTableAdapter extends IDataAdapter {
    fill(dataTable: IDataTable): Promise<any>;
    update(dataTable: IDataTable): Promise<any>;
}

export interface IDataTableSetAdapter extends IDataAdapter {
    fill(dataSet: IDataTableSet): Promise<any>;
    update(dataSet: IDataTableSet): Promise<any>;
}

/** Data Record contaning metainfo such as it's status */
export class Record implements IRecord {
    public table: DataTable<Record>;
}

/**
 * Generic implementation of a dataset link 
 */
export class DataSetLink<T extends IDataSet> implements IDataSetLink {
    public onChangeEvent: IOnDataSetChangeEvent;
    protected _dataSet: T;

    constructor(onChangeEvent: IOnDataSetChangeEvent) {
        this.onChangeEvent = onChangeEvent;
    }

    public get dataSet(): T { return this._dataSet; }
    public set dataSet(value: T) { this.setDataSet(value); }

    public onChange(eventType: DataSetEventType, data?: any): void {
        if (this.onChangeEvent)
            this.onChangeEvent(eventType, data);
    }

    protected setDataSet(value: T) {
        if (this._dataSet != value) {
            if (this._dataSet)
                this._dataSet.removeLink(this);
            this._dataSet = value;
            if (this._dataSet)
                this._dataSet.addLink(this);
            this.onChange(DataSetEventType.Refreshed);
        }
    }
}

/** DataSet containing one table */
export class DataTable<R extends IRecord> implements IDataTable {
    public tableName: string;
    public fields: IField[] = [];
    public records: R[] = [];
    public recordFactory: InstanceFactory<R>;
    public adapter: IDataTableAdapter;
    protected links: IDataSetLink[] = [];

    constructor(recordFactory?: { new (): R }, owner?: DataTableSet, tableName?: string, adapter?: IDataTableAdapter) {
        this.recordFactory = recordFactory;
        this.tableName = tableName;
        if (owner)
            owner.tables.push(this);
        this.adapter = adapter;
        if (!this.adapter)
            this.adapter = new DataTableAdapter(tableName);
    }

    public add(record?: R): R {
        if (!record)
            record = this.createRecord();
        this.records.push(record);
        return record;
    }

    public getMetaInfo(): any {
        if ((<any>this.recordFactory).metaInfo)
            return (<any>this.recordFactory).metaInfo;
        else
            return this.fields;
    }

    // IDataTable implementation

    public addLink(link: IDataSetLink): void {
        this.links.push(link);
    }

    public removeLink(link: IDataSetLink): void {
        let num = this.links.indexOf(link);
        if (num >= 0)
            this.links.splice(num);
    }

    public notifyLinks(eventType: DataSetEventType, data?: any): void {
        for (let i = 0; i < this.links.length; i++) {
            this.links[i].onChange(eventType, data);
        }
    }

    public createRecord(): R {
        let newRec;
        if (this.recordFactory)
            newRec = new this.recordFactory();
        else
            newRec = new Record();
        newRec.table = this;
        return newRec;
    }

    // public internalRead(obj: any): void {
    //     // read from object obj		
    // }

    public fill(): Promise<R[]> {
        return this.adapter.fill(this).then((records: R[]) => {
            // TODO: object instancing
            this.records = records;
            this.notifyLinks(DataSetEventType.Refreshed);
            return records;
        });
    }

    public update(): Promise<any> {
        return this.adapter.update(this);
    }
}

/** DataSet containing several tables */
export class DataTableSet implements IDataTableSet {
    public tables: IDataTable[];
    public adapter: IDataTableSetAdapter;

    public fill(): Promise<any> {
        return this.adapter.fill(this);
    }

    public update(): Promise<any> {
        return this.adapter.update(this);
    }
}

/** DataSource containing one table */
export class TableDataSource<R extends IRecord> extends RecordSetSource {
    protected _data: DataSetLink<DataTable<R>>;

    public get dataTable(): DataTable<R> {
        return this._data.dataSet;
    }
    public set dataTable(dataTable: DataTable<R>) {
        if (this._data.dataSet != dataTable) {
            if (this._data.dataSet)
                this._data.dataSet.removeLink(this._data);
            dataTable.addLink(this._data);
        }
    }

    constructor(dataTable?: DataTable<R>) {
        super();
        this._data = new DataSetLink<DataTable<R>>((eventType: DataSetEventType, data: any) => {
            //TODO: handle different event types
            this.records = this.dataTable.records;
            this.notifyLinks(DataEventType.Refreshed);
        });
        this._data.dataSet = dataTable;
    }
}

/** Perfoms remote data manipulations */
export class DataTableAdapter implements IDataTableAdapter {
    public adapter: string;
    public service: IService;

    constructor(adapter: string) {
        this.adapter = adapter;
    }

    public execute(command: string, params?: any): Promise<any> {
        return this.getService().execute(this.adapter, command, params).then((response: IResponse) => {
            return response.data;
        });
    }

    public fill(dataTable: IDataTable): Promise<any> {
        return this.execute('fill').then((data) => {
            dataTable.records = data.records;
            return dataTable.records;
        });
    }

    public update(dataTable: IDataTable): Promise<any> {
        return this.execute('update').then((data) => {
            dataTable.records = data.records;
            return dataTable.records;
        });
    }

    protected getService(): IService {
        return this.service || application.service;
    }

}


// example code 

/*

class Customer extends Record {
    name: string;
    phone: string;
    static metaInfo =
    {
        name: {
            dataType: 'string',
            dataSize: 20,
            required: false
        }
    }
}

class Order extends Record {
}

class OrderDataSet extends DataSet {
    order = new DataTable(Order, this, 'order');
    customer = new DataTable(Customer, this, 'customer');
}

let order = new OrderDataSet();
order.customer.edit();
order.customer.name = 'Smith';
order.customer.post();
order.update();

let customerTable = new DataTable(Customer);

*/

/*
export class TableDataSet {
    public adapter: string;
    public service: IService;
    public records: IRecord[];

    constructor(adapter?: string) {
        this.adapter = adapter;
    }

    public fill(): Promise<IRecord[]> {
        return this.getService().execute(this.adapter, 'select').then((response: IResponse) => {
            this.records = response.data.records;
            return this.records;
        });
    }

    public updateRecord(index: number): Promise<void> {
        return this.getService().execute(this.adapter, 'update', this.records[index]);
    }

    public insertRecord(index: number): Promise<string> {
        return this.getService().execute(this.adapter, 'insert', this.records[index]).then((response: IResponse) => {
            let keyField = Object.keys(response.data)[0];
            this.records[index][keyField] = response.data[keyField];
            return this.records[index][keyField];
        });
    }

    public deleteRecord(index: number): Promise<void> {
        return this.getService().execute(this.adapter, 'delete', this.records[index]);
    }

    protected getService(): IService {
        return this.service || application.service;
    }
}

export class TableDataSource extends RecordSetSource {
    public dataSet: TableDataSet;

    constructor(dataSet?: TableDataSet) {
        super();
        this.dataSet = dataSet;
    }

    public fill(): Promise<IRecord[]> {
        return this.dataSet.fill().then((records: IRecord[]) => {
            this.records = records;
            this.notifyLinks(EventType.Refreshed);
            this.setState(RecordState.Browse);
            return records;
        });
    }

    public post(): Promise<void> {
        if (this._state == RecordState.Insert)
            return this.dataSet.insertRecord(this._curIndex, ).then(() => {
                super.post();
            });
        else
            return this.dataSet.updateRecord(this._curIndex, ).then(() => {
                super.post();
            });
    }

    public delete(): Promise<void> {
        if (this._state == RecordState.Insert)
            super.delete();
        else
            return this.dataSet.deleteRecord(this._curIndex).then(() => {
                super.delete();
            });
    }


}
*/

